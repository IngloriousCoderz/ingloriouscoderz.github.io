{"data":{"title":"Loopback 4 è un porting di Spring Boot","description":"IBM ha rovinato un bellissimo prodotto, è ora di cercare altrove.","author":"IceOnFire","_entry":"posts\\blog\\2018-10-23-loopback-porting-di-spring-boot.md","page":"post","name":"loopback-porting-di-spring-boot","category":"blog","date":"2018-10-23T00:00:00.000Z","url":"/blog/loopback-porting-di-spring-boot"},"content":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Se c'è una cosa buona che il "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4"},"children":[{"type":"text","value":"faticoso ecosistema JavaScript"}]},{"type":"text","value":" ha portato nelle nostre vite è un ritorno alla "},{"type":"element","tagName":"a","properties":{"href":"https://codeburst.io/functional-programming-in-javascript-e57e7e28c0e5"},"children":[{"type":"text","value":"programmazione funzionale"}]},{"type":"text","value":". Dopo anni e anni a scervellarsi su oggetti, classi e design pattern, Facebook con i suoi "},{"type":"element","tagName":"a","properties":{"href":"https://reactjs.org/"},"children":[{"type":"text","value":"React"}]},{"type":"text","value":" e "},{"type":"element","tagName":"a","properties":{"href":"https://redux.js.org/"},"children":[{"type":"text","value":"Redux"}]},{"type":"text","value":" ci ha convinti a fare marcia indietro e riconsiderare le funzioni pure, l'immutabilità e la composizione a scapito dell'ereditarietà, delle annotation e della dependency injection. A un tratto il codice diventa potente, performante, leggibile e testabile come non lo è mai stato, e la programmazione orientata agli oggetti (o meglio, alle classi) pare solo un brutto ricordo."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Questo almeno per quanto riguarda il front end. E sul back end? Personalmente per progetti un po' più complessi la mia scelta è ricaduta su "},{"type":"element","tagName":"a","properties":{"href":"https://loopback.io/"},"children":[{"type":"text","value":"Loopback 3"}]},{"type":"text","value":", framework di "},{"type":"element","tagName":"a","properties":{"href":"https://strongloop.com/"},"children":[{"type":"text","value":"Strongloop"}]},{"type":"text","value":" (poi acquisita da "},{"type":"element","tagName":"a","properties":{"href":"https://www.ibm.com/"},"children":[{"type":"text","value":"IBM"}]},{"type":"text","value":") che, essendo fortemente basato su "},{"type":"element","tagName":"a","properties":{"href":"https://expressjs.com/"},"children":[{"type":"text","value":"Express"}]},{"type":"text","value":", riesce a rendere la creazione di un server Node immediata e la sua personalizzazione perlomeno fattibile. Basta definire un modello in un linguaggio che sostanzialmente è un'estensione di "},{"type":"element","tagName":"a","properties":{"href":"https://json-schema.org/"},"children":[{"type":"text","value":"JSON Schema"}]},{"type":"text","value":" e si ha automaticamente un servizio REST che fa tutte le operazioni CRUD sul database. Se poi si vogliono definire funzioni custom si possono creare degli hook a vari livelli dell'architettura, oppure dei middleware in stile Express."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Non vedevo l'ora, quindi, di mettere le mani sulla "},{"type":"element","tagName":"a","properties":{"href":"http://v4.loopback.io/"},"children":[{"type":"text","value":"versione 4 di Loopback"}]},{"type":"text","value":", uscita ufficialmente il "},{"type":"element","tagName":"a","properties":{"href":"https://strongloop.com/strongblog/loopback-4-ga"},"children":[{"type":"text","value":"10 ottobre 2018"}]},{"type":"text","value":". Mi aspettavo più potenza, una migliore documentazione, magari il supporto nativo a GraphQL. Ma soprattutto che rimanesse semplice ed elegante com'era. E invece proprio quest'ultimo punto è stato uno stravoglimento totale, per me incomprensibile. Loopback 4 fa uso di "},{"type":"element","tagName":"a","properties":{"href":"https://www.typescriptlang.org/"},"children":[{"type":"text","value":"TypeScript"}]},{"type":"text","value":" (e vabbè, se proprio non potete fare a meno della tipizzazione statica), dei decoratori (e vabbè, basta non abusarne), delle classi (taaaante classi) e ha addirittura un suo sistema di dependency injection!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Da una parte sembra il miglior amico di "},{"type":"element","tagName":"a","properties":{"href":"https://angular.io/"},"children":[{"type":"text","value":"Angular"}]},{"type":"text","value":", framework che non riesco proprio a digerire, dall'altra sembra un porting di "},{"type":"element","tagName":"a","properties":{"href":"http://spring.io/projects/spring-boot"},"children":[{"type":"text","value":"Spring Boot"}]},{"type":"text","value":". Pare come se i Javisti si fossero riversati nel salotto JavaScript e avessero detto: \"Non mi piace qui, dobbiamo riarredare\"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Un esempio? Questo è il codice necessario a definire una relazione uno-a-molti in Loopback 3:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-json"]},"children":[{"type":"text","value":"{\n  \"name\": \"TodoList\",\n  \"base\": \"PersistedModel\",\n  \"relations\": {\n    \"todos\": {\n      \"type\": \"hasMany\",\n      \"model\": \"Todo\",\n      \"foreignKey\": \"todoListId\"\n    }\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ecco lo stesso tipo di relazione definito in Loopback 4:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"import {\n  DefaultCrudRepository,\n  HasManyRepositoryFactory,\n  repository,\n} from '@loopback/repository';\nimport {TodoList, Todo} from '../models';\nimport {DbDataSource} from '../datasources';\nimport {inject, Getter} from '@loopback/core';\nimport {TodoRepository} from './todo.repository';\n\nexport class TodoListRepository extends DefaultCrudRepository<\n  TodoList,\n  typeof TodoList.prototype.id\n> {\n  public readonly todos: HasManyRepositoryFactory<\n    Todo,\n    typeof TodoList.prototype.id\n  >;\n\n  constructor(\n    @inject('datasources.db') dataSource: DbDataSource,\n    @repository.getter(TodoRepository)\n    protected todoRepositoryGetter: Getter<TodoRepository>,\n  ) {\n    super(TodoList, dataSource);\n    this.todos = this._createHasManyRepositoryFactoryFor(\n      'todos',\n      todoRepositoryGetter,\n    );\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"L'esempio è preso dal "},{"type":"element","tagName":"a","properties":{"href":"https://loopback.io/doc/en/lb4/todo-list-tutorial-repository.html"},"children":[{"type":"text","value":"tutorial ufficiale"}]},{"type":"text","value":", che al momento in cui scrivo è anche errato (ho dovuto aggiustare guardando il "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/strongloop/loopback-next/blob/master/examples/todo-list/src/repositories/todo-list.repository.ts"},"children":[{"type":"text","value":"sorgente degli esempi"}]},{"type":"text","value":")."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Inoltre per creare un unico endpoint REST è necessario:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Creare una classe di modello"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Creare una classe datasource"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Creare una classe repository"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Creare una classe controller"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La classe modello descrive le proprietà del modello tramite attributi di istanza e decoratori, mentre prima bastava un po' di JSON."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La classe datasource serve solo a iniettare la configurazione JSON simile a quella che c'era in Loopback 3."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La classe repository serve solo a iniettare la classe datasource."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La classe controller espone tutti i metodi CRUD di base, oportunamente decorati, risultando in circa 130 righe di codice quando in Loopback 3 ne servivano 0."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Parafrasando Bender, mi viene voglia di creare un Loopback tutto mio, con blackjack e squillo di lusso. Anzi, senza blackjack e neanche le squillo, ma almeno più funzionale."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# IceOnFire\n"}]}]}],"data":{"quirksMode":false}},"raw":"\r\nSe c'è una cosa buona che il [faticoso ecosistema JavaScript](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4) ha portato nelle nostre vite è un ritorno alla [programmazione funzionale](https://codeburst.io/functional-programming-in-javascript-e57e7e28c0e5). Dopo anni e anni a scervellarsi su oggetti, classi e design pattern, Facebook con i suoi [React](https://reactjs.org/) e [Redux](https://redux.js.org/) ci ha convinti a fare marcia indietro e riconsiderare le funzioni pure, l'immutabilità e la composizione a scapito dell'ereditarietà, delle annotation e della dependency injection. A un tratto il codice diventa potente, performante, leggibile e testabile come non lo è mai stato, e la programmazione orientata agli oggetti (o meglio, alle classi) pare solo un brutto ricordo.\r\n\r\nQuesto almeno per quanto riguarda il front end. E sul back end? Personalmente per progetti un po' più complessi la mia scelta è ricaduta su [Loopback 3](https://loopback.io/), framework di [Strongloop](https://strongloop.com/) (poi acquisita da [IBM](https://www.ibm.com/)) che, essendo fortemente basato su [Express](https://expressjs.com/), riesce a rendere la creazione di un server Node immediata e la sua personalizzazione perlomeno fattibile. Basta definire un modello in un linguaggio che sostanzialmente è un'estensione di [JSON Schema](https://json-schema.org/) e si ha automaticamente un servizio REST che fa tutte le operazioni CRUD sul database. Se poi si vogliono definire funzioni custom si possono creare degli hook a vari livelli dell'architettura, oppure dei middleware in stile Express.\r\n\r\nNon vedevo l'ora, quindi, di mettere le mani sulla [versione 4 di Loopback](http://v4.loopback.io/), uscita ufficialmente il [10 ottobre 2018](https://strongloop.com/strongblog/loopback-4-ga). Mi aspettavo più potenza, una migliore documentazione, magari il supporto nativo a GraphQL. Ma soprattutto che rimanesse semplice ed elegante com'era. E invece proprio quest'ultimo punto è stato uno stravoglimento totale, per me incomprensibile. Loopback 4 fa uso di [TypeScript](https://www.typescriptlang.org/) (e vabbè, se proprio non potete fare a meno della tipizzazione statica), dei decoratori (e vabbè, basta non abusarne), delle classi (taaaante classi) e ha addirittura un suo sistema di dependency injection!\r\n\r\nDa una parte sembra il miglior amico di [Angular](https://angular.io/), framework che non riesco proprio a digerire, dall'altra sembra un porting di [Spring Boot](http://spring.io/projects/spring-boot). Pare come se i Javisti si fossero riversati nel salotto JavaScript e avessero detto: \"Non mi piace qui, dobbiamo riarredare\".\r\n\r\nUn esempio? Questo è il codice necessario a definire una relazione uno-a-molti in Loopback 3:\r\n\r\n```json\r\n{\r\n  \"name\": \"TodoList\",\r\n  \"base\": \"PersistedModel\",\r\n  \"relations\": {\r\n    \"todos\": {\r\n      \"type\": \"hasMany\",\r\n      \"model\": \"Todo\",\r\n      \"foreignKey\": \"todoListId\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nEcco lo stesso tipo di relazione definito in Loopback 4:\r\n\r\n```js\r\nimport {\r\n  DefaultCrudRepository,\r\n  HasManyRepositoryFactory,\r\n  repository,\r\n} from '@loopback/repository';\r\nimport {TodoList, Todo} from '../models';\r\nimport {DbDataSource} from '../datasources';\r\nimport {inject, Getter} from '@loopback/core';\r\nimport {TodoRepository} from './todo.repository';\r\n\r\nexport class TodoListRepository extends DefaultCrudRepository<\r\n  TodoList,\r\n  typeof TodoList.prototype.id\r\n> {\r\n  public readonly todos: HasManyRepositoryFactory<\r\n    Todo,\r\n    typeof TodoList.prototype.id\r\n  >;\r\n\r\n  constructor(\r\n    @inject('datasources.db') dataSource: DbDataSource,\r\n    @repository.getter(TodoRepository)\r\n    protected todoRepositoryGetter: Getter<TodoRepository>,\r\n  ) {\r\n    super(TodoList, dataSource);\r\n    this.todos = this._createHasManyRepositoryFactoryFor(\r\n      'todos',\r\n      todoRepositoryGetter,\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nL'esempio è preso dal [tutorial ufficiale](https://loopback.io/doc/en/lb4/todo-list-tutorial-repository.html), che al momento in cui scrivo è anche errato (ho dovuto aggiustare guardando il [sorgente degli esempi](https://github.com/strongloop/loopback-next/blob/master/examples/todo-list/src/repositories/todo-list.repository.ts)).\r\n\r\nInoltre per creare un unico endpoint REST è necessario:\r\n\r\n1. Creare una classe di modello\r\n2. Creare una classe datasource\r\n3. Creare una classe repository\r\n4. Creare una classe controller\r\n\r\nLa classe modello descrive le proprietà del modello tramite attributi di istanza e decoratori, mentre prima bastava un po' di JSON.\r\n\r\nLa classe datasource serve solo a iniettare la configurazione JSON simile a quella che c'era in Loopback 3.\r\n\r\nLa classe repository serve solo a iniettare la classe datasource.\r\n\r\nLa classe controller espone tutti i metodi CRUD di base, oportunamente decorati, risultando in circa 130 righe di codice quando in Loopback 3 ne servivano 0.\r\n\r\nParafrasando Bender, mi viene voglia di creare un Loopback tutto mio, con blackjack e squillo di lusso. Anzi, senza blackjack e neanche le squillo, ma almeno più funzionale.\r\n\r\n```\r\n# IceOnFire\r\n```\r\n"}