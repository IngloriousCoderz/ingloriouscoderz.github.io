{"data":{"title":"Migliorare il codice con il currying","description":"La programmazione funzionale sta tornando in auge, e ha i suoi buoni motivi.","author":"Giosk","_entry":"posts/blog/2018-02-08-migliorare-il-codice-con-il-currying.md","page":"post","name":"migliorare-il-codice-con-il-currying","category":"blog","date":"2018-02-08T00:00:00.000Z","url":"/blog/migliorare-il-codice-con-il-currying"},"content":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oggi mi sono trovato davanti a un problema a prima vista molto semplice da realizzare, ma il cui risultato si è rivelato orribile e per niente ottimale.\nIl problema si descrive molto facilmente in linguaggio naturale \"calcolare la differenza tra due liste A e B\".\nFacile no? A prima vista sì, ma scendendo nel tecnico si è rivelato un po' più ostico del previsto, perché le mie due liste erano composte da oggetti, ognuno con più di un parametro e una chiave generata in modo randomico, quindi il problema andrebbe riformulato come \"calcolare la differenza tra due liste di oggetti A e B basandosi su uno dei suoi parametri\".","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":4,"column":362,"offset":626}}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":4,"column":362,"offset":626}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Parlando in JavaScript:","position":{"start":{"line":6,"column":1,"offset":628},"end":{"line":6,"column":24,"offset":651}}}],"position":{"start":{"line":6,"column":1,"offset":628},"end":{"line":6,"column":24,"offset":651}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"let nodesA = [\n  { a: '1', b: '1' },\n  { a: '2', b: '2' },\n  { a: '3', b: '3' },\n  { a: '4', b: '4' },\n  { a: '5', b: '5' },\n]\nlet nodesB = [\n  { a: '1', b: '6' },\n  { a: '2', b: '7' },\n  { a: '3', b: '8' },\n  { a: '6', b: '9' },\n  { a: '7', b: '10' },\n  { a: '8', b: '11' },\n]\n"}],"position":{"start":{"line":8,"column":1,"offset":653},"end":{"line":24,"column":4,"offset":940}}}],"position":{"start":{"line":8,"column":1,"offset":653},"end":{"line":24,"column":4,"offset":940}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Come fare dunque a ottenere come risultato nodesA / nodesB, basandosi sul parametro a?","position":{"start":{"line":26,"column":1,"offset":942},"end":{"line":26,"column":87,"offset":1028}}}],"position":{"start":{"line":26,"column":1,"offset":942},"end":{"line":26,"column":87,"offset":1028}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Questa è la prima versione a cui ho pensato:","position":{"start":{"line":28,"column":1,"offset":1030},"end":{"line":28,"column":45,"offset":1074}}}],"position":{"start":{"line":28,"column":1,"offset":1030},"end":{"line":28,"column":45,"offset":1074}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"let result = []\nnodesB.forEach(nb => {\n  let supportArr = []\n  nodesA.forEach(na => {\n    supportArr.push(na.a)\n  })\n  const notInNodesA = supportArr.indexOf(nb.a) === -1\n  if (notInNodesA) {\n    result.push(nb)\n  }\n})\n"}],"position":{"start":{"line":30,"column":1,"offset":1076},"end":{"line":42,"column":4,"offset":1304}}}],"position":{"start":{"line":30,"column":1,"offset":1076},"end":{"line":42,"column":4,"offset":1304}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"È davvero brutta lo so, è quadratica quindi non ottimale ed è anche un po' scomoda da utilizzare, quindi ho dovuto per forza RIFATTORIZZARE.\nInizialmente mi sono messo in testa di usare il filter e la map, ma non riuscivo a incastrare le cose come volevo (ottenevo o troppi dati o quelli che non mi interessavano) e nella mia ricerca mi sono imbattuto nel concetto di ","position":{"start":{"line":44,"column":1,"offset":1306},"end":{"line":45,"column":228,"offset":1674}}},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Currying"},"children":[{"type":"text","value":"currying","position":{"start":{"line":45,"column":229,"offset":1675},"end":{"line":45,"column":237,"offset":1683}}}],"position":{"start":{"line":45,"column":228,"offset":1674},"end":{"line":45,"column":278,"offset":1724}}},{"type":"text","value":" visto all'università, ma mai utilizzato in pratica.\nLa definizione più semplice e immediata l'ho trovata su ","position":{"start":{"line":45,"column":278,"offset":1724},"end":{"line":46,"column":57,"offset":1833}}},{"type":"element","tagName":"a","properties":{"href":"https://stackoverflow.com/questions/36314/what-is-currying"},"children":[{"type":"text","value":"StackOverflow","position":{"start":{"line":46,"column":58,"offset":1834},"end":{"line":46,"column":71,"offset":1847}}}],"position":{"start":{"line":46,"column":57,"offset":1833},"end":{"line":46,"column":132,"offset":1908}}},{"type":"text","value":" e poi con l'aiuto di un bel post trovato ","position":{"start":{"line":46,"column":132,"offset":1908},"end":{"line":46,"column":174,"offset":1950}}},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe"},"children":[{"type":"text","value":"qua","position":{"start":{"line":46,"column":175,"offset":1951},"end":{"line":46,"column":178,"offset":1954}}}],"position":{"start":{"line":46,"column":174,"offset":1950},"end":{"line":46,"column":247,"offset":2023}}},{"type":"text","value":" sono riuscito dopo un po' di tentativi ed errori a giungere a questo risultato.","position":{"start":{"line":46,"column":247,"offset":2023},"end":{"line":46,"column":327,"offset":2103}}}],"position":{"start":{"line":44,"column":1,"offset":1306},"end":{"line":46,"column":327,"offset":2103}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ho definito la funzione ","position":{"start":{"line":48,"column":1,"offset":2105},"end":{"line":48,"column":25,"offset":2129}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodeCompare"}],"position":{"start":{"line":48,"column":25,"offset":2129},"end":{"line":48,"column":38,"offset":2142}}},{"type":"text","value":" in questo modo:","position":{"start":{"line":48,"column":38,"offset":2142},"end":{"line":48,"column":54,"offset":2158}}}],"position":{"start":{"line":48,"column":1,"offset":2105},"end":{"line":48,"column":54,"offset":2158}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"const nodeCompare = otherArray => {\n  return current => {\n    return (\n      otherArray.filter(other => {\n        return other.a === current.a\n      }).length === 0\n    )\n  }\n}\n"}],"position":{"start":{"line":50,"column":1,"offset":2160},"end":{"line":60,"column":4,"offset":2346}}}],"position":{"start":{"line":50,"column":1,"offset":2160},"end":{"line":60,"column":4,"offset":2346}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"e poi l'ho utilizzata così:","position":{"start":{"line":62,"column":1,"offset":2348},"end":{"line":62,"column":28,"offset":2375}}}],"position":{"start":{"line":62,"column":1,"offset":2348},"end":{"line":62,"column":28,"offset":2375}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"const difference = nodesB.filter(nodeCompare(nodesA))\n"}],"position":{"start":{"line":64,"column":1,"offset":2377},"end":{"line":66,"column":4,"offset":2440}}}],"position":{"start":{"line":64,"column":1,"offset":2377},"end":{"line":66,"column":4,"offset":2440}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ho quindi applicato all'array ","position":{"start":{"line":68,"column":1,"offset":2442},"end":{"line":68,"column":31,"offset":2472}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodesB"}],"position":{"start":{"line":68,"column":31,"offset":2472},"end":{"line":68,"column":39,"offset":2480}}},{"type":"text","value":" un filtro che riceve come callback ","position":{"start":{"line":68,"column":39,"offset":2480},"end":{"line":68,"column":75,"offset":2516}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodeCompare"}],"position":{"start":{"line":68,"column":75,"offset":2516},"end":{"line":68,"column":88,"offset":2529}}},{"type":"text","value":".\nLa funzione nodeCompare riceve come parametro l'array ","position":{"start":{"line":68,"column":88,"offset":2529},"end":{"line":69,"column":55,"offset":2585}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodesA"}],"position":{"start":{"line":69,"column":55,"offset":2585},"end":{"line":69,"column":63,"offset":2593}}},{"type":"text","value":" che restituisce a sua volta il risultato di un filtro applicato sul ","position":{"start":{"line":69,"column":63,"offset":2593},"end":{"line":69,"column":132,"offset":2662}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodesB"}],"position":{"start":{"line":69,"column":132,"offset":2662},"end":{"line":69,"column":140,"offset":2670}}},{"type":"text","value":", e se il risultato è vuoto o pieno mi restituirà ","position":{"start":{"line":69,"column":140,"offset":2670},"end":{"line":69,"column":190,"offset":2720}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"true"}],"position":{"start":{"line":69,"column":190,"offset":2720},"end":{"line":69,"column":196,"offset":2726}}},{"type":"text","value":" o ","position":{"start":{"line":69,"column":196,"offset":2726},"end":{"line":69,"column":199,"offset":2729}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"false"}],"position":{"start":{"line":69,"column":199,"offset":2729},"end":{"line":69,"column":206,"offset":2736}}},{"type":"text","value":" permettendo al primo filter lanciato di decidere se il valore è di mio interesse oppure no.\nUn salto di qualità notevole dopo la prima versione!","position":{"start":{"line":69,"column":206,"offset":2736},"end":{"line":70,"column":53,"offset":2881}}}],"position":{"start":{"line":68,"column":1,"offset":2442},"end":{"line":70,"column":53,"offset":2881}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Spero con questo piccolo post di aver aiutato qualcuno o anche semplicemente spronato al REFACTORING, cosa che noi Inglorious Coders diciamo di fare sempre!","position":{"start":{"line":72,"column":1,"offset":2883},"end":{"line":72,"column":157,"offset":3039}}}],"position":{"start":{"line":72,"column":1,"offset":2883},"end":{"line":72,"column":157,"offset":3039}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# Giosk\n"}],"position":{"start":{"line":74,"column":1,"offset":3041},"end":{"line":74,"column":12,"offset":3052}}}],"position":{"start":{"line":74,"column":1,"offset":3041},"end":{"line":74,"column":12,"offset":3052}}}],"data":{"quirksMode":false},"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1,"column":1,"offset":0}}},"raw":"\nOggi mi sono trovato davanti a un problema a prima vista molto semplice da realizzare, ma il cui risultato si è rivelato orribile e per niente ottimale.\nIl problema si descrive molto facilmente in linguaggio naturale \"calcolare la differenza tra due liste A e B\".\nFacile no? A prima vista sì, ma scendendo nel tecnico si è rivelato un po' più ostico del previsto, perché le mie due liste erano composte da oggetti, ognuno con più di un parametro e una chiave generata in modo randomico, quindi il problema andrebbe riformulato come \"calcolare la differenza tra due liste di oggetti A e B basandosi su uno dei suoi parametri\".\n\nParlando in JavaScript:\n\n```js\nlet nodesA = [\n  { a: '1', b: '1' },\n  { a: '2', b: '2' },\n  { a: '3', b: '3' },\n  { a: '4', b: '4' },\n  { a: '5', b: '5' },\n]\nlet nodesB = [\n  { a: '1', b: '6' },\n  { a: '2', b: '7' },\n  { a: '3', b: '8' },\n  { a: '6', b: '9' },\n  { a: '7', b: '10' },\n  { a: '8', b: '11' },\n]\n```\n\nCome fare dunque a ottenere come risultato nodesA / nodesB, basandosi sul parametro a?\n\nQuesta è la prima versione a cui ho pensato:\n\n```js\nlet result = []\nnodesB.forEach(nb => {\n  let supportArr = []\n  nodesA.forEach(na => {\n    supportArr.push(na.a)\n  })\n  const notInNodesA = supportArr.indexOf(nb.a) === -1\n  if (notInNodesA) {\n    result.push(nb)\n  }\n})\n```\n\nÈ davvero brutta lo so, è quadratica quindi non ottimale ed è anche un po' scomoda da utilizzare, quindi ho dovuto per forza RIFATTORIZZARE.\nInizialmente mi sono messo in testa di usare il filter e la map, ma non riuscivo a incastrare le cose come volevo (ottenevo o troppi dati o quelli che non mi interessavano) e nella mia ricerca mi sono imbattuto nel concetto di [currying](https://en.wikipedia.org/wiki/Currying) visto all'università, ma mai utilizzato in pratica.\nLa definizione più semplice e immediata l'ho trovata su [StackOverflow](https://stackoverflow.com/questions/36314/what-is-currying) e poi con l'aiuto di un bel post trovato [qua](https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe) sono riuscito dopo un po' di tentativi ed errori a giungere a questo risultato.\n\nHo definito la funzione `nodeCompare` in questo modo:\n\n```js\nconst nodeCompare = otherArray => {\n  return current => {\n    return (\n      otherArray.filter(other => {\n        return other.a === current.a\n      }).length === 0\n    )\n  }\n}\n```\n\ne poi l'ho utilizzata così:\n\n```js\nconst difference = nodesB.filter(nodeCompare(nodesA))\n```\n\nHo quindi applicato all'array `nodesB` un filtro che riceve come callback `nodeCompare`.\nLa funzione nodeCompare riceve come parametro l'array `nodesA` che restituisce a sua volta il risultato di un filtro applicato sul `nodesB`, e se il risultato è vuoto o pieno mi restituirà `true` o `false` permettendo al primo filter lanciato di decidere se il valore è di mio interesse oppure no.\nUn salto di qualità notevole dopo la prima versione!\n\nSpero con questo piccolo post di aver aiutato qualcuno o anche semplicemente spronato al REFACTORING, cosa che noi Inglorious Coders diciamo di fare sempre!\n\n    # Giosk\n"}