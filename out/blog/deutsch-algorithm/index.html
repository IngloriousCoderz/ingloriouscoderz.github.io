<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" class="next-head"/><meta property="og:type" content="website" class="next-head"/><meta property="og:image" content="https://www.ingloriouscoderz.it/static/images/backgrounds/metal-800x600.png" class="next-head"/><meta property="og:image:alt" content="Inglorious Coderz" class="next-head"/><meta property="og:image:width" content="800" class="next-head"/><meta property="og:image:height" content="600" class="next-head"/><meta property="og:locale" content="en_US" class="next-head"/><meta property="og:site_name" content="Inglorious Coderz" class="next-head"/><title class="next-head">Deutsch Algorithm | Inglorious Coderz</title><meta name="robots" content="index,follow" class="next-head"/><meta name="googlebot" content="index,follow" class="next-head"/><meta name="description" content="Using quantum superposition to guess the kind of a function in sub-exponential time." class="next-head"/><meta property="og:url" content="https://www.ingloriouscoderz.it/blog/deutsch-algorithm" class="next-head"/><meta property="og:title" content="Deutsch Algorithm | Inglorious Coderz" class="next-head"/><meta property="og:description" content="Using quantum superposition to guess the kind of a function in sub-exponential time." class="next-head"/><link rel="canonical" href="https://www.ingloriouscoderz.it/blog/deutsch-algorithm" class="next-head"/><link rel="preload" href="/_next/static/~9o0Bk8o0_vyj9di0Sup4/pages/post.js" as="script"/><link rel="preload" href="/_next/static/~9o0Bk8o0_vyj9di0Sup4/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/~9o0Bk8o0_vyj9di0Sup4/pages/_error.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-146a87c69ce1d8ee4106.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.252a03706053abbd9579.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.848a10fb03a6f2a79b6d.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-81f7b6421b0b80e0b5a7.js" as="script"/><link rel="stylesheet" href="/_next/static/css/styles.ec205546.chunk.css"/><style id="__jsx-2096718123">.button.jsx-2096718123{-webkit-flex:1;-ms-flex:1;flex:1;background-color:rgba(40,44,52,0.5);margin:0.25rem;border:1px solid #429aef;padding:0.25rem 0.5rem;text-transform:uppercase;line-height:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}
div.jsx-2096718123{height:100%;}</style><style id="__jsx-2522996044">.toolbar.jsx-2522996044{padding:0.5rem 0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}
.toolbar.jsx-2522996044>div.jsx-2522996044{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}</style><style id="__jsx-3278221705">.logo.jsx-3278221705{width:64px;-webkit-perspective:64px;-moz-perspective:64px;-ms-perspective:64px;perspective:64px;margin:0 auto;}
.cube.jsx-3278221705{height:64px;-webkit-transform-style:preserve-3d;-ms-transform-style:preserve-3d;transform-style:preserve-3d;-webkit-transform:scaleY(1.2) translateZ(-64px) rotateX(-0.6981317007977318rad) rotateY(-0.7853981633974483rad);-ms-transform:scaleY(1.2) translateZ(-64px) rotateX(-0.6981317007977318rad) rotateY(-0.7853981633974483rad);transform:scaleY(1.2) translateZ(-64px) rotateX(-0.6981317007977318rad) rotateY(-0.7853981633974483rad);-webkit-transition:ease-out 0.2s;transition:ease-out 0.2s;}
.cube__face.jsx-3278221705{position:absolute;width:100%;height:100%;-webkit-transform-origin:bottom center;-ms-transform-origin:bottom center;transform-origin:bottom center;}
.cube__face.jsx-3278221705>img.jsx-3278221705{position:absolute;}
.cube__face--left.jsx-3278221705{-webkit-transform:rotateY(0deg) translateZ(32px) skew(12deg);-ms-transform:rotateY(0deg) translateZ(32px) skew(12deg);transform:rotateY(0deg) translateZ(32px) skew(12deg);}
.cube__face--right.jsx-3278221705{-webkit-transform:rotateY(90deg) translateZ(32px) skew(-12deg);-ms-transform:rotateY(90deg) translateZ(32px) skew(-12deg);transform:rotateY(90deg) translateZ(32px) skew(-12deg);}
.cube__face--right.jsx-3278221705>.eye.jsx-3278221705{-webkit-transform:rotateY(180deg);-ms-transform:rotateY(180deg);transform:rotateY(180deg);}
.cube__face--left.jsx-3278221705>img.jsx-3278221705:first-of-type{;}
.cube__face--right.jsx-3278221705>img.jsx-3278221705:first-of-type{;}</style><style id="__jsx-2692775195">header.jsx-2692775195{background:black;background-image:url(/_next/static/images/metal-wallpaper-3332ea3aa68955eb3406abac6a06f036.jpg);background-position-x:center;background-attachment:fixed;margin-bottom:1rem;position:-webkit-sticky;position:sticky;top:0;z-index:1000;}
header.jsx-2692775195>h1.jsx-2692775195{font-size:2rem;}
@media (max-width:575.98px){header.jsx-2692775195>h1.jsx-2692775195{font-size:1rem;}}
header.jsx-2692775195>h1.jsx-2692775195 .title.jsx-2692775195{font-family:'Ethnocentric';color:#666;display:grid;justify-items:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;grid-template-columns:4fr 1fr 4fr;}
.shade.jsx-2692775195{position:relative;margin:-1.5rem 0 0;padding:0;display:block;background:#111;width:100%;height:1.5rem;opacity:0.25;text-align:center;}
@media (max-width:575.98px){.shade.jsx-2692775195{margin:-0.75rem 0 0;height:1rem;}}
header.jsx-2692775195>p.jsx-2692775195{text-align:center;margin:0.5rem;}
nav.jsx-2692775195{text-align:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style><style id="__jsx-2421455553">article.jsx-2421455553>time.jsx-2421455553{display:block;margin-top:-0.5rem;margin-bottom:1rem;color:#9a9a9a;}</style><style id="__jsx-453059934">footer.jsx-453059934{background:black;font-size:small;text-align:center;padding:1rem;}
footer.jsx-453059934 img.jsx-453059934{display:inline-block;margin:0;border-radius:0;vertical-align:middle;}</style><style id="__jsx-417973436">@font-face{font-family:'Ethnocentric';font-display:auto;font-style:normal;font-weight:400;src:url('/static/fonts/ethnocentric_rg.ttf') format('truetype');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6, U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193, U+2212,U+2215,U+FEFF,U+FFFD;}
@font-face{font-family:'Orbitron';font-display:auto;font-style:normal;font-weight:400;src:url('/static/fonts/orbitron.woff2') format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6, U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193, U+2212,U+2215,U+FEFF,U+FFFD;}
@font-face{font-family:'Roboto';font-display:auto;font-style:normal;font-weight:400;src:url('/static/fonts/roboto.woff2') format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6, U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193, U+2212,U+2215,U+FEFF,U+FFFD;}
@font-face{font-family:'Fira Code';font-display:auto;font-style:normal;font-weight:400;src:url('/static/fonts/firacode.woff2') format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6, U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193, U+2212,U+2215,U+FEFF,U+FFFD;}
:focus{outline:none;}
::-moz-focus-inner{border:0;}
html,body,#__next{height:100%;margin:0;}
html{font-family:'Roboto','Ubuntu',sans-serif;font-size:16px;line-height:1.5;color:#bbb;}
body,.layout{background:black;background-image:url(/_next/static/images/metal-wallpaper-3332ea3aa68955eb3406abac6a06f036.jpg);background-position-x:center;background-attachment:fixed;}
 a{color:#429aef;-webkit-text-decoration:none;text-decoration:none;}
a:hover{-webkit-filter:brightness(125%);filter:brightness(125%);}
h1,h2,h3{font-family:'Orbitron';font-weight:normal;color:#98c379;}
h1{font-size:1.5rem;}
h2{font-size:1.2rem;}
p{margin-top:0;}
p:last-child{margin-bottom:0;}
img{display:block;vertical-align:middle;max-width:100%;margin:0 auto;}
input[type='checkbox']{vertical-align:middle;}
pre,code{font-family:'Fira Code';}
pre{white-space:pre-wrap;word-break:break-all;word-wrap:break-word;}
code{font-size:14px;color:#abb2bf;background:#282c34;}
blockquote{margin:0;margin-bottom:1rem;padding:0 1rem;border-left:0.25rem solid #bbb;}
blockquote>p:before{content:'“';font-size:2rem;line-height:0.1rem;margin-right:0.5rem;vertical-align:-0.5rem;}
blockquote>p:last-of-type:after{content:'”';font-size:2rem;line-height:0.1rem;margin-right:0.5rem;vertical-align:-0.5rem;}
.text-right{text-align:right;}
.card{margin-bottom:1rem;padding:1rem;background-color:rgba(40,44,52,0.5);}
.card-1{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);-webkit-transition:all 0.3s cubic-bezier(0.25,0.8,0.25,1);transition:all 0.3s cubic-bezier(0.25,0.8,0.25,1);}
.card-1:hover{box-shadow:0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);}
.container-fluid{padding-left:1rem;padding-right:1rem;}
.row>*{height:100%;}
.svg-inline--fa.fa-w-16{width:1em;}
.svg-inline--fa.fa-w-14{width:0.875em;}
.svg-inline--fa{display:inline-block;font-size:inherit;height:1em;overflow:visible;vertical-align:-0.125em;}
.mapboxgl-map{position:relative;}
.mapboxgl-marker{position:absolute;}</style><style id="__jsx-1352889155">.layout.jsx-1352889155{max-width:1024px;margin:0 auto;height:100%;display:grid;grid-template-rows:auto auto 1fr auto;}
main.jsx-1352889155{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:column;-ms-flex-flow:column;flex-flow:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}</style><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0"/><link rel="apple-touch-icon" sizes="180x180" href="/static/icons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/static/icons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/static/icons/favicon-16x16.png"/><link rel="manifest" href="/static/site.webmanifest"/><link rel="mask-icon" href="/static/icons/safari-pinned-tab.svg" color="#000000"/><meta name="msapplication-TileColor" content="#000000"/><meta name="theme-color" content="#000000"/><meta name="google-site-verification" content="RFVNvxmtxJpN5XtPqm_lrA2jrphy-Sn_fy3XyekO-2E"/><meta property="fb:app_id" content="1677017469210661"/><script src="/static/scripts/gh-spa-redirect.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script></head><body><div id="__next"><div class="jsx-1352889155 jsx-417973436 layout container-fluid"><div class="jsx-2522996044 toolbar"><div class="jsx-2522996044"><a href="https://www.facebook.com/IngloriousCoderz/" target="_blank" rel="noopener noreferrer" aria-label="Facebook" class="jsx-2096718123 button"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="facebook" class="svg-inline--fa fa-facebook fa-w-16 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"></path></svg></a><a href="https://www.instagram.com/ingloriouscoderz/" target="_blank" rel="noopener noreferrer" aria-label="Instagram" class="jsx-2096718123 button"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="instagram" class="svg-inline--fa fa-instagram fa-w-14 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></svg></a><a href="https://github.com/IngloriousCoderz/" target="_blank" rel="noopener noreferrer" aria-label="Github" class="jsx-2096718123 button"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="https://www.linkedin.com/company/inglorious-coderz/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn" class="jsx-2096718123 button"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="mailto:antony.mistretta@gmail.com" target="_blank" rel="noopener noreferrer" aria-label="Email" class="jsx-2096718123 button"><svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="envelope" class="svg-inline--fa fa-envelope fa-w-16 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"></path></svg></a><a href="tel:+393202357664" target="_blank" rel="noopener noreferrer" aria-label="WhatsApp" class="jsx-2096718123 button"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="whatsapp" class="svg-inline--fa fa-whatsapp fa-w-14 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"></path></svg></a></div><div class="jsx-2522996044"><a class="jsx-2096718123 button" href="/privacy-policy/">Privacy</a></div></div><header class="jsx-2692775195"><h1 class="jsx-2692775195"><a href="/"><div class="jsx-2692775195 title"><div class="jsx-2692775195"><span class="jsx-2692775195">Inglorious</span><span class="jsx-2692775195 shade"> </span></div><div class="jsx-3278221705 logo"><div class="jsx-3278221705 cube"><div class="jsx-3278221705 cube__face cube__face--left"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiPjxwYXRoIGQ9Ik0wIDBoNkw0IDF2NGwyIDFIMGwyLTFWMXoiIGZpbGw9IiM3ZjdmZmYiIGZpbGwtb3BhY2l0eT0iLjUiIHN0cm9rZT0iIzdmN2ZjMCIgc3Ryb2tlLXdpZHRoPSIuMjUiIHN0cm9rZS1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==" alt="I" class="jsx-3278221705"/><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiPjxwYXRoIGQ9Ik0wIDBoMWwxLjUuNzVoMkw0IDFIMnoiIGZpbGw9IiMwMGMwYzAiIGZpbGwtb3BhY2l0eT0iLjUiLz48cGF0aCBkPSJNMSAwaDVMNC41Ljc1aC0yeiIgZmlsbD0iIzBmZiIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==" alt="left eye" class="jsx-3278221705 eye"/></div><div class="jsx-3278221705 cube__face cube__face--right"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiPjxwYXRoIGQ9Ik0wIDBoNnYyTDQgMUgydjRoMmwyLTF2MkgweiIgZmlsbD0iIzdmN2ZmZiIgZmlsbC1vcGFjaXR5PSIuNSIgc3Ryb2tlPSIjN2Y3ZmMwIiBzdHJva2Utd2lkdGg9Ii4yNSIgc3Ryb2tlLW9wYWNpdHk9Ii41Ii8+PC9zdmc+" alt="C" class="jsx-3278221705"/></div></div></div><div class="jsx-2692775195"><span class="jsx-2692775195">Coderz</span><span class="jsx-2692775195 shade"> </span></div></div></a></h1><nav class="jsx-2692775195"><a class="jsx-2096718123 button" href="/why/">Why</a><a class="jsx-2096718123 button" href="/who/">Who</a><a class="jsx-2096718123 button" href="/what/">What</a><a class="jsx-2096718123 button" href="/how/">How</a><a class="jsx-2096718123 button" href="/when/">When</a><a class="jsx-2096718123 button" href="/where/">Where</a><a class="jsx-2096718123 button" href="/how-much/">How Much</a><a class="jsx-2096718123 button" href="/icy/">Icy</a><a class="jsx-2096718123 button" href="/blog/">Blog</a></nav></header><main class="jsx-1352889155 jsx-417973436"><article class="jsx-2421455553 card card-1"><h1 class="jsx-2421455553">Deutsch Algorithm</h1><time dateTime="2020-04-25T00:00:00.000Z" class="jsx-2421455553">4/25/2020</time><div><p>In April 7, 2020 I was introduced to the fundamentals of Quantum Computing, and it was love at first sight. I started studying <a href="https://www.python.org/" target="_blank" rel="noopener noreferrer">Python</a> and <a href="https://qiskit.org/" target="_blank" rel="noopener noreferrer">Qiskit</a> and <a href="https://jupyter.org/" target="_blank" rel="noopener noreferrer">Jupyter</a> notebooks and, after working hard on the basics for a dozen days, I was stuck with the most basic algorithm. But then I worked even harder, and I got it finally. Here is the result of my studies as an exported Jupyter notebook.</p>
<pre><code class="language-python">from qiskit import QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.quantum_info import Operator
</code></pre>
<p>Say we have a function <span class="math math-inline">f</span> which takes some zeroes and ones as input and returns 0 or 1 according to some logic. We cannot inspect the function, but we can invoke it as a black box and, based on the output of our experiments, we are able to understand the underlying logic. We call such a function an &quot;oracle&quot;.</p>
<p>A one-bit oracle will only be able to produce the following results:</p>
<ol>
<li><span class="math math-inline">f(0) = 0, f(1) = 0</span></li>
<li><span class="math math-inline">f(0) = 1, f(1) = 1</span></li>
<li><span class="math math-inline">f(0) = 0, f(1) = 1</span></li>
<li><span class="math math-inline">f(0) = 1, f(1) = 0</span></li>
</ol>
<p>If the oracle behaves like 1. or 2. it means that whatever input I use I will always obtain the same result: the function is then considered &quot;constant&quot; (always zero or always one). If instead it behaves like 3. or 4. it means that sometimes I get 0 and sometimes 1: the function could then be considered &quot;variable&quot;, although in the more generic algorithm of Deutsch-Josza we use the term &quot;balanced&quot; so we are going to use it here too (a balanced function gives 0 for half of the inputs and 1 for the other half, which by the way applies here too).</p>
<p>Although possibly confusing, we can call these functions for future reference like so:</p>
<ol>
<li>Zero: always gives 0 (constant)</li>
<li>One: always gives 1 (constant)</li>
<li>Identity: gives the unchanged input (balanced)</li>
<li>Negation: gives the inverted input (balanced)</li>
</ol>
<h2>The Classical Way</h2>
<p>In order to guess the logic a classical computer would need to call the function twice:</p>
<pre><code class="language-python">def guess(f):
    constant = 0
    balanced = 1

    if f(0) == 0:
        if f(1) == 0:
            return constant # zero
        elif f(1) == 1:
            return balanced # identity
    elif f(0) == 1:
        if f(1) == 0:
            return balanced # negation
        elif f(1) == 1:
            return constant # one

def zero(bit):
    return 0

def one(bit):
    return 1

def identity(bit):
    return bit

def negation(bit):
    return 1 if bit == 0 else 0

def test_guess(name, type):
    print(name, &#x27;is&#x27;, &#x27;constant&#x27; if guess(type) == 0 else &#x27;balanced&#x27;)

test_guess(&#x27;Zero&#x27;, zero)
test_guess(&#x27;One&#x27;, one)
test_guess(&#x27;Identity&#x27;, identity)
test_guess(&#x27;Negation&#x27;, negation)
</code></pre>
<pre><code>Zero is constant
One is constant
Identity is balanced
Negation is balanced
</code></pre>
<p>The Deutsch algorithm instead guesses if the oracle is constant or balanced with just one call to <code>f</code>, using the magic of quantum superposition. We will see how, but first we have to redefine the oracle in the quantum world.</p>
<h2>The Oracle</h2>
<p>We could think that the oracle is a single-qubit gate, with just an input and an output:</p>
<pre><code>input    +--------+    output
  |x⟩ ---| oracle |--- |f(x)⟩
         +--------+
</code></pre>
<p>As <a href="https://youtu.be/F_Riqjdh2oM" target="_blank" rel="noopener noreferrer">this YouTube video</a> shows, the matrices associated to the four operations we can do on a single qubit are as follows:</p>
<ol>
<li>Zero (constant): <span class="math math-inline">\begin{bmatrix}1 &amp; 1\\0 &amp; 0\end{bmatrix}</span></li>
<li>One (constant): <span class="math math-inline">\begin{bmatrix}0 &amp; 0\\1 &amp; 1\end{bmatrix}</span></li>
<li>Identity (balanced): <span class="math math-inline">\begin{bmatrix}1 &amp; 0\\0 &amp; 1\end{bmatrix}</span></li>
<li>Negation (balanced): <span class="math math-inline">\begin{bmatrix}0 &amp; 1\\1 &amp; 0\end{bmatrix}</span> (equal to the Pauli gate X)</li>
</ol>
<p>However these turn out to be useless, especially the first two since they are not even unitary.</p>
<p>As any gate in a quantum circuit, the oracle must be reversible (i.e. applying it twice will produce the Identity matrix). That&#x27;s why we need to convert it into a two-qubits gate: the first qubit is the input value of the function, which isn&#x27;t supposed to change, and the second qubit usually starts with |0⟩ and will change into the result of the oracle:</p>
<pre><code> input    +--------+    input&#x27;
   |x⟩ ---|        |--- |x⟩
          | oracle |
   |0⟩ ---|        |--- |f(x)⟩
output    +--------+    output&#x27;
</code></pre>
<p><em>Spoiler alert:</em> when plugging the oracle in the Deutsch algorithm, <code>output</code> will instead be initialized as <span class="math math-inline">|1\rangle</span> and as a side effect <code>input&#x27;</code> will turn out to be <span class="math math-inline">|0\rangle</span> if the oracle is constant, and <span class="math math-inline">|1\rangle</span> if the oracle is balanced.</p>
<pre><code class="language-python">qubits = 2
input = 0
output = 1
</code></pre>
<h3>Defining The Four Operators</h3>
<p>But how do we implement the four different oracles? One way we could find the unitary matrices instead is by analyzing the expected output. Let&#x27;s try with Zero:</p>
<div class="math math-display">Zero \cdot |00\rangle = |00\rangle\\
Zero \cdot |01\rangle = |01\rangle</div>
<p>So the vectors <span class="math math-inline">\begin{bmatrix}1\\0\\0\\0\end{bmatrix}</span> and <span class="math math-inline">\begin{bmatrix}0\\1\\0\\0\end{bmatrix}</span> are mapped to themselves. This suggests the following matrix:</p>
<div class="math math-display">Zero = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
? &amp; ? &amp; ? &amp; ?\\
? &amp; ? &amp; ? &amp; ?
\end{bmatrix}</div>
<p>Note that we don&#x27;t care about the third and fourth rows, so we could just complete the matrix as an Identity.</p>
<pre><code class="language-python">zero = Operator([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1]
])
</code></pre>
<p>This operator corresponds to not doing anthing at all inside the oracle!</p>
<pre><code> input    +------+    input&#x27;
   |x⟩ ---| ---- |--- |x⟩
          |      |
   |0⟩ ---| ---- |--- |0⟩
output    +------+    output&#x27;
</code></pre>
<p>Let&#x27;s try now with One:</p>
<div class="math math-display">One \cdot |00\rangle = |10\rangle\\
One \cdot |01\rangle = |11\rangle</div>
<p>So <span class="math math-inline">\begin{bmatrix}1\\0\\0\\0\end{bmatrix} \rightarrow \begin{bmatrix}0\\0\\1\\0\end{bmatrix}</span> and <span class="math math-inline">\begin{bmatrix}0\\1\\0\\0\end{bmatrix} \rightarrow \begin{bmatrix}0\\0\\0\\1\end{bmatrix}</span> (first position mapped to third, second position mapped to fourth). This suggests the following matrix:</p>
<div class="math math-display">One = \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0
\end{bmatrix}</div>
<pre><code class="language-python">one = Operator([
    [0, 0, 1, 0],
    [0, 0, 0, 1],
    [1, 0, 0, 0],
    [0, 1, 0, 0]
])
</code></pre>
<p>This operator corresponds to just putting an X gate on the output!</p>
<pre><code> input    +---------+    input&#x27;
   |x⟩ ---| ------- |--- |x⟩
          |         |
   |0⟩ ---| --|X|-- |--- |1⟩
output    +---------+    output&#x27;
</code></pre>
<p>Now for Identity:</p>
<div class="math math-display">Identity \cdot |00\rangle = |00\rangle\\
Identity \cdot |01\rangle = |11\rangle</div>
<p>So <span class="math math-inline">\begin{bmatrix}1\\0\\0\\0\end{bmatrix} \rightarrow \begin{bmatrix}1\\0\\0\\0\end{bmatrix}</span> and <span class="math math-inline">\begin{bmatrix}0\\1\\0\\0\end{bmatrix} \rightarrow \begin{bmatrix}0\\0\\0\\1\end{bmatrix}</span> (first position mapped to itself, second position mapped to fourth). This suggests the following matrix:</p>
<div class="math math-display">Identity = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0
\end{bmatrix}</div>
<pre><code class="language-python">identity = Operator([
    [1, 0, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0],
    [0, 1, 0, 0]
])
</code></pre>
<p>This operator looks a lot like a CNOT on the output:</p>
<pre><code> input    +---------+    input&#x27;
   |x⟩ ---| ---*--- |--- |x⟩
          |    |    |
   |0⟩ ---| --|X|-- |--- |0⟩ or |1⟩, depending on |x⟩
output    +---------+    output&#x27;
</code></pre>
<p>And finally Negation:</p>
<div class="math math-display">Negation \cdot |00\rangle = |10\rangle\\
Negation \cdot |01\rangle = |01\rangle</div>
<p>So <span class="math math-inline">\begin{bmatrix}1\\0\\0\\0\end{bmatrix} \rightarrow \begin{bmatrix}0\\0\\1\\0\end{bmatrix}</span> and <span class="math math-inline">\begin{bmatrix}0\\1\\0\\0\end{bmatrix} \rightarrow \begin{bmatrix}0\\0\\0\\1\end{bmatrix}</span> (first position mapped to third, second position mapped to itself). This suggests the following matrix:</p>
<div class="math math-display">Negation = \begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}</div>
<pre><code class="language-python">negation = Operator([
    [0, 0, 1, 0],
    [0, 1, 0, 0],
    [1, 0, 0, 0],
    [0, 0, 0, 1]
])
</code></pre>
<p>This operator could be interpreted as a CNOT on the output, sandwiched by two negations on the input:</p>
<pre><code> input    +---------------+    input&#x27;
   |x⟩ ---| --|X|-*-|X|-- |--- |x⟩
          |       |       |
   |0⟩ ---| -----|X|----- |--- |1⟩ or |0⟩, depending on |x⟩
output    +---------------+    output&#x27;
</code></pre>
<p>Why is that? Well, if we look at the truth table:</p>



































<table><thead><tr><th>output</th><th>input</th><th>output&#x27;</th><th>input&#x27;</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table>
<p>We can see it as a CNOT from <code>input</code> to <code>output</code>, but:</p>
<ul>
<li><code>output&#x27;</code> is flipped when input is 0 instead of 1 so we need to negate <code>input</code> before applying the CNOT; and</li>
<li><code>input</code> must be negated again afterwards to turn back to its original state.</li>
</ul>
<p>It&#x27;s easy to prove that <span class="math math-inline">(I \otimes X) \cdot CX \cdot (I \otimes X)</span> gives that same exact matrix.</p>
<p>Or, as the YouTube video shows, we can even see it as a CNOT with a subsequent negation on <code>output</code>, which makes even more sense!</p>
<pre><code> input    +-------------+    input&#x27;
   |x⟩ ---| ---*------- |--- |x⟩
          |    |        |
   |0⟩ ---| --|X|-|X|-- |--- |1⟩ or |0⟩, depending on |x⟩
output    +-------------+    output&#x27;
</code></pre>
<h3>Implementing The Oracle</h3>
<p>We can finally define our oracle as a circuit that can make use of one of these four operators.</p>
<pre><code class="language-python">def oracle(type):
    oracle = QuantumCircuit(qubits, name=&#x27;oracle&#x27;)
    oracle.append(type, range(qubits))
    return oracle
</code></pre>
<p>We can verify that the operators are well defined by invoking the following test function using all possible combinations.</p>
<pre><code class="language-python">def test_oracle(type, q1=0, q0=0):
    circuit = QuantumCircuit(2, 1)
    if (q0 == 1):
        circuit.x(input)
    if (q1 == 1):
        circuit.x(output)
    circuit.append(oracle(type), range(qubits))
    circuit.measure(output, 0)
    backend = Aer.get_backend(&#x27;qasm_simulator&#x27;)
    return execute(circuit, backend, shots=1, memory=True).result().get_memory()[0]

print(&#x27;Zero(0):&#x27;, test_oracle(zero, q0=0), &#x27;\tZero(1):&#x27;, test_oracle(zero, q0=1))
print(&#x27;One(0):&#x27;, test_oracle(one, q0=0), &#x27;\tOne(1):&#x27;, test_oracle(one, q0=1))
print(&#x27;Identity(0):&#x27;, test_oracle(identity, q0=0), &#x27;\tIdentity(1):&#x27;, test_oracle(identity, q0=1))
print(&#x27;Negation(0):&#x27;, test_oracle(negation, q0=0), &#x27;\tNegation(1):&#x27;, test_oracle(negation, q0=1))
</code></pre>
<pre><code>Zero(0): 0  Zero(1): 0
One(0): 1   One(1): 1
Identity(0): 0  Identity(1): 1
Negation(0): 1  Negation(1): 0
</code></pre>
<h2>The Algorithm</h2>
<p>The Deutsch algorithm is pretty straightforward. It just does the following:</p>
<ol>
<li>Negates the <code>output</code> qubit so it starts with <span class="math math-inline">|1\rangle</span></li>
<li>Applies Hadamard gates to both input and output to turn them into a superposition</li>
<li>Applies the oracle, whichever it is</li>
<li>Converts back the input with a Hadamard gate and measures it, since it now holds the answer to the question: &quot;is the function balanced?&quot;</li>
</ol>
<p>Note that we don&#x27;t measure the output, since it&#x27;s irrelevant and yields the wrong result anyway.</p>
<pre><code class="language-python">def deutsch(oracle):
    cbits = 1
    circuit = QuantumCircuit(qubits, cbits, name=&#x27;deutsch&#x27;)
    circuit.x(output)
    circuit.barrier()
    circuit.h(input)
    circuit.h(output)
    circuit.append(oracle.to_instruction(), range(qubits))
    circuit.h(input)
    circuit.barrier()
    circuit.measure(input, 0)
    return circuit

circuit = deutsch(oracle(zero))
circuit.draw(output=&#x27;mpl&#x27;)
</code></pre>
<p><img src="/static/images/blog/deutsch.png" alt="png"/></p>
<pre><code class="language-python">def test_deutsch(name, type):
    circuit = deutsch(oracle(type))
    backend = Aer.get_backend(&#x27;qasm_simulator&#x27;)
    guess = execute(circuit, backend, shots=1, memory=True).result().get_memory()[0]
    print(name, &#x27;is&#x27;, &#x27;constant&#x27; if guess == &#x27;0&#x27; else &#x27;balanced&#x27;)

test_deutsch(&#x27;Zero&#x27;, zero)
test_deutsch(&#x27;One&#x27;, one)
test_deutsch(&#x27;Identity&#x27;, identity)
test_deutsch(&#x27;Negation&#x27;, negation)
</code></pre>
<pre><code>Zero is constant
One is constant
Identity is balanced
Negation is balanced
</code></pre>
<p>Intuitively, the difference between Zero and One or Identity and Negation is lost in the Z-basis but the difference between constant and balanced is amplified, because when the function is balanced superposition flips the input qubit.</p>
<p>We came up with the same results as the classical algorithm, but with just one call to the function <span class="math math-inline">f</span>. QED</p>
<pre><code># IceOnFire
</code></pre></div></article></main><footer class="jsx-453059934"><a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener noreferrer"><img alt="Licenza Creative Commons" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAANDQwNDQ0NDg0ODg4PEA8REREZGRkgICAhISEiIiIkJSMnKCcuMC4xMzEzMzM5Ozk7PTtBQkFCQkJDQ0NERERLTEtVVVVbXltmZmZna2dydnF3d3d9gn2AgICGhoaHh4eIiIiPkI+UmZOZmZmqqqqrsaqzuLK6v7q7u7vFxsXGysbIzMjKzsrMzMzd3d3u7u7///+uXr4hAAAA2klEQVQ4y62T6RKCMAyEIyIq3kc961GBeCN5/5eTalupozOONMMfluVjk1AA50VOSwJR1gKEkpgfIV5rf6bTwMgX5iOsjXhYlwQOmq/UKcwQL5NywKqgNASWMQhTYt28552arzIV/FK2AE+bBVzBkcIpcR5kcUK8mvd8Us8fl/Hru2+CBi4hzeRWpj3ZM/cR92eTUNn0uxpvC/QxIZsHGY+Je3ZCKHZIdsI3wczQE5QEMM9n2LvRuGPN0Ab+NkPsNxxvOapsDXDUcvAf5mvZKN6wXvakuD7LjusO1DVRlsjT/rIAAAAASUVORK5CYII=" class="jsx-453059934"/></a> INGLORIOUS CODERZ DI MISTRETTA MATTEO ANTONY | 39 Via Val Della Torre, 10149 Torino (TO) | VAT Code IT11524720015 | Tax Code MSTMTN82R17H501A</footer></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"post":{"data":{"title":"Deutsch Algorithm","description":"Using quantum superposition to guess the kind of a function in sub-exponential time.","author":"IceOnFire","_entry":"posts/blog/2020-04-25-deutsch-algorithm.md","page":"post","name":"deutsch-algorithm","category":"blog","date":"2020-04-25T00:00:00.000Z","url":"/blog/deutsch-algorithm"},"content":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In April 7, 2020 I was introduced to the fundamentals of Quantum Computing, and it was love at first sight. I started studying "},{"type":"element","tagName":"a","properties":{"href":"https://www.python.org/"},"children":[{"type":"text","value":"Python"}]},{"type":"text","value":" and "},{"type":"element","tagName":"a","properties":{"href":"https://qiskit.org/"},"children":[{"type":"text","value":"Qiskit"}]},{"type":"text","value":" and "},{"type":"element","tagName":"a","properties":{"href":"https://jupyter.org/"},"children":[{"type":"text","value":"Jupyter"}]},{"type":"text","value":" notebooks and, after working hard on the basics for a dozen days, I was stuck with the most basic algorithm. But then I worked even harder, and I got it finally. Here is the result of my studies as an exported Jupyter notebook."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"from qiskit import QuantumCircuit, Aer, execute\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nfrom qiskit.quantum_info import Operator\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Say we have a function "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"f"}]},{"type":"text","value":" which takes some zeroes and ones as input and returns 0 or 1 according to some logic. We cannot inspect the function, but we can invoke it as a black box and, based on the output of our experiments, we are able to understand the underlying logic. We call such a function an \"oracle\"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A one-bit oracle will only be able to produce the following results:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"f(0) = 0, f(1) = 0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"f(0) = 1, f(1) = 1"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"f(0) = 0, f(1) = 1"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"f(0) = 1, f(1) = 0"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If the oracle behaves like 1. or 2. it means that whatever input I use I will always obtain the same result: the function is then considered \"constant\" (always zero or always one). If instead it behaves like 3. or 4. it means that sometimes I get 0 and sometimes 1: the function could then be considered \"variable\", although in the more generic algorithm of Deutsch-Josza we use the term \"balanced\" so we are going to use it here too (a balanced function gives 0 for half of the inputs and 1 for the other half, which by the way applies here too)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Although possibly confusing, we can call these functions for future reference like so:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Zero: always gives 0 (constant)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"One: always gives 1 (constant)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Identity: gives the unchanged input (balanced)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Negation: gives the inverted input (balanced)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"The Classical Way"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In order to guess the logic a classical computer would need to call the function twice:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"def guess(f):\n    constant = 0\n    balanced = 1\n\n    if f(0) == 0:\n        if f(1) == 0:\n            return constant # zero\n        elif f(1) == 1:\n            return balanced # identity\n    elif f(0) == 1:\n        if f(1) == 0:\n            return balanced # negation\n        elif f(1) == 1:\n            return constant # one\n\ndef zero(bit):\n    return 0\n\ndef one(bit):\n    return 1\n\ndef identity(bit):\n    return bit\n\ndef negation(bit):\n    return 1 if bit == 0 else 0\n\ndef test_guess(name, type):\n    print(name, 'is', 'constant' if guess(type) == 0 else 'balanced')\n\ntest_guess('Zero', zero)\ntest_guess('One', one)\ntest_guess('Identity', identity)\ntest_guess('Negation', negation)\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Zero is constant\nOne is constant\nIdentity is balanced\nNegation is balanced\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Deutsch algorithm instead guesses if the oracle is constant or balanced with just one call to "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"f"}]},{"type":"text","value":", using the magic of quantum superposition. We will see how, but first we have to redefine the oracle in the quantum world."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"The Oracle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We could think that the oracle is a single-qubit gate, with just an input and an output:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"input    +--------+    output\n  |x⟩ ---| oracle |--- |f(x)⟩\n         +--------+\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As "},{"type":"element","tagName":"a","properties":{"href":"https://youtu.be/F_Riqjdh2oM"},"children":[{"type":"text","value":"this YouTube video"}]},{"type":"text","value":" shows, the matrices associated to the four operations we can do on a single qubit are as follows:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Zero (constant): "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}1 \u0026 1\\\\0 \u0026 0\\end{bmatrix}"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"One (constant): "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}0 \u0026 0\\\\1 \u0026 1\\end{bmatrix}"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Identity (balanced): "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}1 \u0026 0\\\\0 \u0026 1\\end{bmatrix}"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Negation (balanced): "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}0 \u0026 1\\\\1 \u0026 0\\end{bmatrix}"}]},{"type":"text","value":" (equal to the Pauli gate X)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However these turn out to be useless, especially the first two since they are not even unitary."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"As any gate in a quantum circuit, the oracle must be reversible (i.e. applying it twice will produce the Identity matrix). That's why we need to convert it into a two-qubits gate: the first qubit is the input value of the function, which isn't supposed to change, and the second qubit usually starts with |0⟩ and will change into the result of the oracle:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" input    +--------+    input'\n   |x⟩ ---|        |--- |x⟩\n          | oracle |\n   |0⟩ ---|        |--- |f(x)⟩\noutput    +--------+    output'\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Spoiler alert:"}]},{"type":"text","value":" when plugging the oracle in the Deutsch algorithm, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"output"}]},{"type":"text","value":" will instead be initialized as "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"|1\\rangle"}]},{"type":"text","value":" and as a side effect "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"input'"}]},{"type":"text","value":" will turn out to be "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"|0\\rangle"}]},{"type":"text","value":" if the oracle is constant, and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"|1\\rangle"}]},{"type":"text","value":" if the oracle is balanced."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"qubits = 2\ninput = 0\noutput = 1\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Defining The Four Operators"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"But how do we implement the four different oracles? One way we could find the unitary matrices instead is by analyzing the expected output. Let's try with Zero:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"Zero \\cdot |00\\rangle = |00\\rangle\\\\\nZero \\cdot |01\\rangle = |01\\rangle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So the vectors "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix}"}]},{"type":"text","value":" and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix}"}]},{"type":"text","value":" are mapped to themselves. This suggests the following matrix:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"Zero = \\begin{bmatrix}\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\\\\\n? \u0026 ? \u0026 ? \u0026 ?\\\\\n? \u0026 ? \u0026 ? \u0026 ?\n\\end{bmatrix}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Note that we don't care about the third and fourth rows, so we could just complete the matrix as an Identity."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"zero = Operator([\n    [1, 0, 0, 0],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1]\n])\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This operator corresponds to not doing anthing at all inside the oracle!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" input    +------+    input'\n   |x⟩ ---| ---- |--- |x⟩\n          |      |\n   |0⟩ ---| ---- |--- |0⟩\noutput    +------+    output'\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Let's try now with One:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"One \\cdot |00\\rangle = |10\\rangle\\\\\nOne \\cdot |01\\rangle = |11\\rangle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\1\\\\0\\end{bmatrix}"}]},{"type":"text","value":" and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}"}]},{"type":"text","value":" (first position mapped to third, second position mapped to fourth). This suggests the following matrix:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"One = \\begin{bmatrix}\n0 \u0026 0 \u0026 1 \u0026 0\\\\\n0 \u0026 0 \u0026 0 \u0026 1\\\\\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\n\\end{bmatrix}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"one = Operator([\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [1, 0, 0, 0],\n    [0, 1, 0, 0]\n])\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This operator corresponds to just putting an X gate on the output!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" input    +---------+    input'\n   |x⟩ ---| ------- |--- |x⟩\n          |         |\n   |0⟩ ---| --|X|-- |--- |1⟩\noutput    +---------+    output'\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Now for Identity:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"Identity \\cdot |00\\rangle = |00\\rangle\\\\\nIdentity \\cdot |01\\rangle = |11\\rangle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix}"}]},{"type":"text","value":" and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}"}]},{"type":"text","value":" (first position mapped to itself, second position mapped to fourth). This suggests the following matrix:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"Identity = \\begin{bmatrix}\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 0 \u0026 0 \u0026 1\\\\\n0 \u0026 0 \u0026 1 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\n\\end{bmatrix}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"identity = Operator([\n    [1, 0, 0, 0],\n    [0, 0, 0, 1],\n    [0, 0, 1, 0],\n    [0, 1, 0, 0]\n])\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This operator looks a lot like a CNOT on the output:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" input    +---------+    input'\n   |x⟩ ---| ---*--- |--- |x⟩\n          |    |    |\n   |0⟩ ---| --|X|-- |--- |0⟩ or |1⟩, depending on |x⟩\noutput    +---------+    output'\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"And finally Negation:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"Negation \\cdot |00\\rangle = |10\\rangle\\\\\nNegation \\cdot |01\\rangle = |01\\rangle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\1\\\\0\\end{bmatrix}"}]},{"type":"text","value":" and "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}"}]},{"type":"text","value":" (first position mapped to third, second position mapped to itself). This suggests the following matrix:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["math","math-display"]},"children":[{"type":"text","value":"Negation = \\begin{bmatrix}\n0 \u0026 0 \u0026 1 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\\\\\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 0 \u0026 0 \u0026 1\n\\end{bmatrix}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"negation = Operator([\n    [0, 0, 1, 0],\n    [0, 1, 0, 0],\n    [1, 0, 0, 0],\n    [0, 0, 0, 1]\n])\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This operator could be interpreted as a CNOT on the output, sandwiched by two negations on the input:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" input    +---------------+    input'\n   |x⟩ ---| --|X|-*-|X|-- |--- |x⟩\n          |       |       |\n   |0⟩ ---| -----|X|----- |--- |1⟩ or |0⟩, depending on |x⟩\noutput    +---------------+    output'\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Why is that? Well, if we look at the truth table:"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"output"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"input"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"output'"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"input'"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"0"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"1"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We can see it as a CNOT from "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"input"}]},{"type":"text","value":" to "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"output"}]},{"type":"text","value":", but:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"output'"}]},{"type":"text","value":" is flipped when input is 0 instead of 1 so we need to negate "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"input"}]},{"type":"text","value":" before applying the CNOT; and"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"input"}]},{"type":"text","value":" must be negated again afterwards to turn back to its original state."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"It's easy to prove that "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"(I \\otimes X) \\cdot CX \\cdot (I \\otimes X)"}]},{"type":"text","value":" gives that same exact matrix."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Or, as the YouTube video shows, we can even see it as a CNOT with a subsequent negation on "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"output"}]},{"type":"text","value":", which makes even more sense!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" input    +-------------+    input'\n   |x⟩ ---| ---*------- |--- |x⟩\n          |    |        |\n   |0⟩ ---| --|X|-|X|-- |--- |1⟩ or |0⟩, depending on |x⟩\noutput    +-------------+    output'\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Implementing The Oracle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We can finally define our oracle as a circuit that can make use of one of these four operators."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"def oracle(type):\n    oracle = QuantumCircuit(qubits, name='oracle')\n    oracle.append(type, range(qubits))\n    return oracle\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We can verify that the operators are well defined by invoking the following test function using all possible combinations."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"def test_oracle(type, q1=0, q0=0):\n    circuit = QuantumCircuit(2, 1)\n    if (q0 == 1):\n        circuit.x(input)\n    if (q1 == 1):\n        circuit.x(output)\n    circuit.append(oracle(type), range(qubits))\n    circuit.measure(output, 0)\n    backend = Aer.get_backend('qasm_simulator')\n    return execute(circuit, backend, shots=1, memory=True).result().get_memory()[0]\n\nprint('Zero(0):', test_oracle(zero, q0=0), '\\tZero(1):', test_oracle(zero, q0=1))\nprint('One(0):', test_oracle(one, q0=0), '\\tOne(1):', test_oracle(one, q0=1))\nprint('Identity(0):', test_oracle(identity, q0=0), '\\tIdentity(1):', test_oracle(identity, q0=1))\nprint('Negation(0):', test_oracle(negation, q0=0), '\\tNegation(1):', test_oracle(negation, q0=1))\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Zero(0): 0  Zero(1): 0\nOne(0): 1   One(1): 1\nIdentity(0): 0  Identity(1): 1\nNegation(0): 1  Negation(1): 0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"The Algorithm"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The Deutsch algorithm is pretty straightforward. It just does the following:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Negates the "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"output"}]},{"type":"text","value":" qubit so it starts with "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"|1\\rangle"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Applies Hadamard gates to both input and output to turn them into a superposition"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Applies the oracle, whichever it is"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Converts back the input with a Hadamard gate and measures it, since it now holds the answer to the question: \"is the function balanced?\""}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Note that we don't measure the output, since it's irrelevant and yields the wrong result anyway."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"def deutsch(oracle):\n    cbits = 1\n    circuit = QuantumCircuit(qubits, cbits, name='deutsch')\n    circuit.x(output)\n    circuit.barrier()\n    circuit.h(input)\n    circuit.h(output)\n    circuit.append(oracle.to_instruction(), range(qubits))\n    circuit.h(input)\n    circuit.barrier()\n    circuit.measure(input, 0)\n    return circuit\n\ncircuit = deutsch(oracle(zero))\ncircuit.draw(output='mpl')\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/static/images/blog/deutsch.png","alt":"png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"def test_deutsch(name, type):\n    circuit = deutsch(oracle(type))\n    backend = Aer.get_backend('qasm_simulator')\n    guess = execute(circuit, backend, shots=1, memory=True).result().get_memory()[0]\n    print(name, 'is', 'constant' if guess == '0' else 'balanced')\n\ntest_deutsch('Zero', zero)\ntest_deutsch('One', one)\ntest_deutsch('Identity', identity)\ntest_deutsch('Negation', negation)\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Zero is constant\nOne is constant\nIdentity is balanced\nNegation is balanced\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Intuitively, the difference between Zero and One or Identity and Negation is lost in the Z-basis but the difference between constant and balanced is amplified, because when the function is balanced superposition flips the input qubit."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"We came up with the same results as the classical algorithm, but with just one call to the function "},{"type":"element","tagName":"span","properties":{"className":["math","math-inline"]},"children":[{"type":"text","value":"f"}]},{"type":"text","value":". QED"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# IceOnFire\n"}]}]}],"data":{"quirksMode":false}},"raw":"\nIn April 7, 2020 I was introduced to the fundamentals of Quantum Computing, and it was love at first sight. I started studying [Python](https://www.python.org/) and [Qiskit](https://qiskit.org/) and [Jupyter](https://jupyter.org/) notebooks and, after working hard on the basics for a dozen days, I was stuck with the most basic algorithm. But then I worked even harder, and I got it finally. Here is the result of my studies as an exported Jupyter notebook.\n\n```python\nfrom qiskit import QuantumCircuit, Aer, execute\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nfrom qiskit.quantum_info import Operator\n```\n\nSay we have a function $f$ which takes some zeroes and ones as input and returns 0 or 1 according to some logic. We cannot inspect the function, but we can invoke it as a black box and, based on the output of our experiments, we are able to understand the underlying logic. We call such a function an \"oracle\".\n\nA one-bit oracle will only be able to produce the following results:\n\n1. $f(0) = 0, f(1) = 0$\n2. $f(0) = 1, f(1) = 1$\n3. $f(0) = 0, f(1) = 1$\n4. $f(0) = 1, f(1) = 0$\n\nIf the oracle behaves like 1. or 2. it means that whatever input I use I will always obtain the same result: the function is then considered \"constant\" (always zero or always one). If instead it behaves like 3. or 4. it means that sometimes I get 0 and sometimes 1: the function could then be considered \"variable\", although in the more generic algorithm of Deutsch-Josza we use the term \"balanced\" so we are going to use it here too (a balanced function gives 0 for half of the inputs and 1 for the other half, which by the way applies here too).\n\nAlthough possibly confusing, we can call these functions for future reference like so:\n\n1. Zero: always gives 0 (constant)\n2. One: always gives 1 (constant)\n3. Identity: gives the unchanged input (balanced)\n4. Negation: gives the inverted input (balanced)\n\n## The Classical Way\n\nIn order to guess the logic a classical computer would need to call the function twice:\n\n```python\ndef guess(f):\n    constant = 0\n    balanced = 1\n\n    if f(0) == 0:\n        if f(1) == 0:\n            return constant # zero\n        elif f(1) == 1:\n            return balanced # identity\n    elif f(0) == 1:\n        if f(1) == 0:\n            return balanced # negation\n        elif f(1) == 1:\n            return constant # one\n\ndef zero(bit):\n    return 0\n\ndef one(bit):\n    return 1\n\ndef identity(bit):\n    return bit\n\ndef negation(bit):\n    return 1 if bit == 0 else 0\n\ndef test_guess(name, type):\n    print(name, 'is', 'constant' if guess(type) == 0 else 'balanced')\n\ntest_guess('Zero', zero)\ntest_guess('One', one)\ntest_guess('Identity', identity)\ntest_guess('Negation', negation)\n```\n\n    Zero is constant\n    One is constant\n    Identity is balanced\n    Negation is balanced\n\nThe Deutsch algorithm instead guesses if the oracle is constant or balanced with just one call to `f`, using the magic of quantum superposition. We will see how, but first we have to redefine the oracle in the quantum world.\n\n## The Oracle\n\nWe could think that the oracle is a single-qubit gate, with just an input and an output:\n\n```\ninput    +--------+    output\n  |x⟩ ---| oracle |--- |f(x)⟩\n         +--------+\n```\n\nAs [this YouTube video](https://youtu.be/F_Riqjdh2oM) shows, the matrices associated to the four operations we can do on a single qubit are as follows:\n\n1. Zero (constant): $\\begin{bmatrix}1 \u0026 1\\\\0 \u0026 0\\end{bmatrix}$\n2. One (constant): $\\begin{bmatrix}0 \u0026 0\\\\1 \u0026 1\\end{bmatrix}$\n3. Identity (balanced): $\\begin{bmatrix}1 \u0026 0\\\\0 \u0026 1\\end{bmatrix}$\n4. Negation (balanced): $\\begin{bmatrix}0 \u0026 1\\\\1 \u0026 0\\end{bmatrix}$ (equal to the Pauli gate X)\n\nHowever these turn out to be useless, especially the first two since they are not even unitary.\n\nAs any gate in a quantum circuit, the oracle must be reversible (i.e. applying it twice will produce the Identity matrix). That's why we need to convert it into a two-qubits gate: the first qubit is the input value of the function, which isn't supposed to change, and the second qubit usually starts with |0⟩ and will change into the result of the oracle:\n\n```\n input    +--------+    input'\n   |x⟩ ---|        |--- |x⟩\n          | oracle |\n   |0⟩ ---|        |--- |f(x)⟩\noutput    +--------+    output'\n```\n\n_Spoiler alert:_ when plugging the oracle in the Deutsch algorithm, `output` will instead be initialized as $|1\\rangle$ and as a side effect `input'` will turn out to be $|0\\rangle$ if the oracle is constant, and $|1\\rangle$ if the oracle is balanced.\n\n```python\nqubits = 2\ninput = 0\noutput = 1\n```\n\n### Defining The Four Operators\n\nBut how do we implement the four different oracles? One way we could find the unitary matrices instead is by analyzing the expected output. Let's try with Zero:\n\n$$\nZero \\cdot |00\\rangle = |00\\rangle\\\\\nZero \\cdot |01\\rangle = |01\\rangle\n$$\n\nSo the vectors $\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix}$ and $\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix}$ are mapped to themselves. This suggests the following matrix:\n\n$$\nZero = \\begin{bmatrix}\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\\\\\n? \u0026 ? \u0026 ? \u0026 ?\\\\\n? \u0026 ? \u0026 ? \u0026 ?\n\\end{bmatrix}\n$$\n\nNote that we don't care about the third and fourth rows, so we could just complete the matrix as an Identity.\n\n```python\nzero = Operator([\n    [1, 0, 0, 0],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1]\n])\n```\n\nThis operator corresponds to not doing anthing at all inside the oracle!\n\n```\n input    +------+    input'\n   |x⟩ ---| ---- |--- |x⟩\n          |      |\n   |0⟩ ---| ---- |--- |0⟩\noutput    +------+    output'\n```\n\nLet's try now with One:\n\n$$\nOne \\cdot |00\\rangle = |10\\rangle\\\\\nOne \\cdot |01\\rangle = |11\\rangle\n$$\n\nSo $\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\1\\\\0\\end{bmatrix}$ and $\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}$ (first position mapped to third, second position mapped to fourth). This suggests the following matrix:\n\n$$\nOne = \\begin{bmatrix}\n0 \u0026 0 \u0026 1 \u0026 0\\\\\n0 \u0026 0 \u0026 0 \u0026 1\\\\\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\n\\end{bmatrix}\n$$\n\n```python\none = Operator([\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [1, 0, 0, 0],\n    [0, 1, 0, 0]\n])\n```\n\nThis operator corresponds to just putting an X gate on the output!\n\n```\n input    +---------+    input'\n   |x⟩ ---| ------- |--- |x⟩\n          |         |\n   |0⟩ ---| --|X|-- |--- |1⟩\noutput    +---------+    output'\n```\n\nNow for Identity:\n\n$$\nIdentity \\cdot |00\\rangle = |00\\rangle\\\\\nIdentity \\cdot |01\\rangle = |11\\rangle\n$$\n\nSo $\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix}$ and $\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}$ (first position mapped to itself, second position mapped to fourth). This suggests the following matrix:\n\n$$\nIdentity = \\begin{bmatrix}\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 0 \u0026 0 \u0026 1\\\\\n0 \u0026 0 \u0026 1 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\n\\end{bmatrix}\n$$\n\n```python\nidentity = Operator([\n    [1, 0, 0, 0],\n    [0, 0, 0, 1],\n    [0, 0, 1, 0],\n    [0, 1, 0, 0]\n])\n```\n\nThis operator looks a lot like a CNOT on the output:\n\n```\n input    +---------+    input'\n   |x⟩ ---| ---*--- |--- |x⟩\n          |    |    |\n   |0⟩ ---| --|X|-- |--- |0⟩ or |1⟩, depending on |x⟩\noutput    +---------+    output'\n```\n\nAnd finally Negation:\n\n$$\nNegation \\cdot |00\\rangle = |10\\rangle\\\\\nNegation \\cdot |01\\rangle = |01\\rangle\n$$\n\nSo $\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\1\\\\0\\end{bmatrix}$ and $\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix} \\rightarrow \\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}$ (first position mapped to third, second position mapped to itself). This suggests the following matrix:\n\n$$\nNegation = \\begin{bmatrix}\n0 \u0026 0 \u0026 1 \u0026 0\\\\\n0 \u0026 1 \u0026 0 \u0026 0\\\\\n1 \u0026 0 \u0026 0 \u0026 0\\\\\n0 \u0026 0 \u0026 0 \u0026 1\n\\end{bmatrix}\n$$\n\n```python\nnegation = Operator([\n    [0, 0, 1, 0],\n    [0, 1, 0, 0],\n    [1, 0, 0, 0],\n    [0, 0, 0, 1]\n])\n```\n\nThis operator could be interpreted as a CNOT on the output, sandwiched by two negations on the input:\n\n```\n input    +---------------+    input'\n   |x⟩ ---| --|X|-*-|X|-- |--- |x⟩\n          |       |       |\n   |0⟩ ---| -----|X|----- |--- |1⟩ or |0⟩, depending on |x⟩\noutput    +---------------+    output'\n```\n\nWhy is that? Well, if we look at the truth table:\n\n| output | input | output' | input' |\n| ------ | ----- | ------- | ------ |\n| 0      | 0     | 1       | 0      |\n| 0      | 1     | 0       | 1      |\n| 1      | 0     | 0       | 0      |\n| 1      | 1     | 1       | 1      |\n\nWe can see it as a CNOT from `input` to `output`, but:\n\n- `output'` is flipped when input is 0 instead of 1 so we need to negate `input` before applying the CNOT; and\n- `input` must be negated again afterwards to turn back to its original state.\n\nIt's easy to prove that $(I \\otimes X) \\cdot CX \\cdot (I \\otimes X)$ gives that same exact matrix.\n\nOr, as the YouTube video shows, we can even see it as a CNOT with a subsequent negation on `output`, which makes even more sense!\n\n```\n input    +-------------+    input'\n   |x⟩ ---| ---*------- |--- |x⟩\n          |    |        |\n   |0⟩ ---| --|X|-|X|-- |--- |1⟩ or |0⟩, depending on |x⟩\noutput    +-------------+    output'\n```\n\n### Implementing The Oracle\n\nWe can finally define our oracle as a circuit that can make use of one of these four operators.\n\n```python\ndef oracle(type):\n    oracle = QuantumCircuit(qubits, name='oracle')\n    oracle.append(type, range(qubits))\n    return oracle\n```\n\nWe can verify that the operators are well defined by invoking the following test function using all possible combinations.\n\n```python\ndef test_oracle(type, q1=0, q0=0):\n    circuit = QuantumCircuit(2, 1)\n    if (q0 == 1):\n        circuit.x(input)\n    if (q1 == 1):\n        circuit.x(output)\n    circuit.append(oracle(type), range(qubits))\n    circuit.measure(output, 0)\n    backend = Aer.get_backend('qasm_simulator')\n    return execute(circuit, backend, shots=1, memory=True).result().get_memory()[0]\n\nprint('Zero(0):', test_oracle(zero, q0=0), '\\tZero(1):', test_oracle(zero, q0=1))\nprint('One(0):', test_oracle(one, q0=0), '\\tOne(1):', test_oracle(one, q0=1))\nprint('Identity(0):', test_oracle(identity, q0=0), '\\tIdentity(1):', test_oracle(identity, q0=1))\nprint('Negation(0):', test_oracle(negation, q0=0), '\\tNegation(1):', test_oracle(negation, q0=1))\n```\n\n    Zero(0): 0 \tZero(1): 0\n    One(0): 1 \tOne(1): 1\n    Identity(0): 0 \tIdentity(1): 1\n    Negation(0): 1 \tNegation(1): 0\n\n## The Algorithm\n\nThe Deutsch algorithm is pretty straightforward. It just does the following:\n\n1. Negates the `output` qubit so it starts with $|1\\rangle$\n2. Applies Hadamard gates to both input and output to turn them into a superposition\n3. Applies the oracle, whichever it is\n4. Converts back the input with a Hadamard gate and measures it, since it now holds the answer to the question: \"is the function balanced?\"\n\nNote that we don't measure the output, since it's irrelevant and yields the wrong result anyway.\n\n```python\ndef deutsch(oracle):\n    cbits = 1\n    circuit = QuantumCircuit(qubits, cbits, name='deutsch')\n    circuit.x(output)\n    circuit.barrier()\n    circuit.h(input)\n    circuit.h(output)\n    circuit.append(oracle.to_instruction(), range(qubits))\n    circuit.h(input)\n    circuit.barrier()\n    circuit.measure(input, 0)\n    return circuit\n\ncircuit = deutsch(oracle(zero))\ncircuit.draw(output='mpl')\n```\n\n![png](/static/images/blog/deutsch.png)\n\n```python\ndef test_deutsch(name, type):\n    circuit = deutsch(oracle(type))\n    backend = Aer.get_backend('qasm_simulator')\n    guess = execute(circuit, backend, shots=1, memory=True).result().get_memory()[0]\n    print(name, 'is', 'constant' if guess == '0' else 'balanced')\n\ntest_deutsch('Zero', zero)\ntest_deutsch('One', one)\ntest_deutsch('Identity', identity)\ntest_deutsch('Negation', negation)\n```\n\n    Zero is constant\n    One is constant\n    Identity is balanced\n    Negation is balanced\n\nIntuitively, the difference between Zero and One or Identity and Negation is lost in the Z-basis but the difference between constant and balanced is amplified, because when the function is balanced superposition flips the input qubit.\n\nWe came up with the same results as the classical algorithm, but with just one call to the function $f$. QED\n\n```\n# IceOnFire\n```\n"},"_entriesMap":{"/":{"pathname":"/index"},"/blog/hello-world":{"pathname":"/post","query":{"_entry":"posts/blog/2016-02-21-hello-world.md"}},"/blog/il-vaso-di-piva":{"pathname":"/post","query":{"_entry":"posts/blog/2016-05-11-il-vaso-di-piva.md"}},"/blog/resistere-alla-tentazione-del-procedurale-in-redux":{"pathname":"/post","query":{"_entry":"posts/blog/2016-07-21-resistere-alla-tentazione-del-procedurale-in-redux.md"}},"/blog/pokemon-go-e-la-teoria-degli-effetti-collaterali":{"pathname":"/post","query":{"_entry":"posts/blog/2016-07-22-pokemon-go-e-la-teoria-degli-effetti-collaterali.md"}},"/blog/componenti-react-redux-come-librerie":{"pathname":"/post","query":{"_entry":"posts/blog/2016-11-16-componenti-react-redux-come-librerie.md"}},"/blog/migliorare-il-codice-con-il-currying":{"pathname":"/post","query":{"_entry":"posts/blog/2018-02-08-migliorare-il-codice-con-il-currying.md"}},"/blog/loopback-porting-di-spring-boot":{"pathname":"/post","query":{"_entry":"posts/blog/2018-10-23-loopback-porting-di-spring-boot.md"}},"/blog/deutsch-algorithm":{"pathname":"/post","query":{"_entry":"posts/blog/2020-04-25-deutsch-algorithm.md"}},"/why":{"pathname":"/why"},"/who":{"pathname":"/who"},"/who/consultant":{"pathname":"/who/consultant"},"/who/tech-lead":{"pathname":"/who/tech-lead"},"/who/mentor":{"pathname":"/who/mentor"},"/who/teacher":{"pathname":"/who/teacher"},"/what":{"pathname":"/what"},"/what/code":{"pathname":"/what/code"},"/what/speak":{"pathname":"/what/speak"},"/what/speak/conferences":{"pathname":"/what/speak/conferences"},"/what/volunteer":{"pathname":"/what/volunteer"},"/what/community":{"pathname":"/what/community"},"/how":{"pathname":"/how"},"/when":{"pathname":"/when"},"/where":{"pathname":"/where"},"/how-much":{"pathname":"/how-much"},"/icy":{"pathname":"/icy"},"/blog":{"pathname":"/blog"},"/privacy-policy":{"pathname":"/privacy-policy"}}}},"page":"/post","query":{"_entry":"posts/blog/2020-04-25-deutsch-algorithm.md"},"buildId":"~9o0Bk8o0_vyj9di0Sup4","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/post" src="/_next/static/~9o0Bk8o0_vyj9di0Sup4/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/~9o0Bk8o0_vyj9di0Sup4/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/static/~9o0Bk8o0_vyj9di0Sup4/pages/_error.js"></script><script src="/_next/static/runtime/webpack-146a87c69ce1d8ee4106.js" async=""></script><script src="/_next/static/chunks/commons.252a03706053abbd9579.js" async=""></script><script src="/_next/static/chunks/styles.848a10fb03a6f2a79b6d.js" async=""></script><script src="/_next/static/runtime/main-81f7b6421b0b80e0b5a7.js" async=""></script></body></html>