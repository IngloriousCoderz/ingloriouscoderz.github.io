{"data":{"title":"Migliorare il codice con il currying","description":"La programmazione funzionale sta tornando in auge, e ha i suoi buoni motivi.","author":"Giosk","_entry":"posts\\blog\\2018-02-08-migliorare-il-codice-con-il-currying.md","page":"post","name":"migliorare-il-codice-con-il-currying","category":"blog","date":"2018-02-08T00:00:00.000Z","url":"/blog/migliorare-il-codice-con-il-currying"},"content":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oggi mi sono trovato davanti a un problema a prima vista molto semplice da realizzare, ma il cui risultato si è rivelato orribile e per niente ottimale.\nIl problema si descrive molto facilmente in linguaggio naturale \"calcolare la differenza tra due liste A e B\".\nFacile no? A prima vista sì, ma scendendo nel tecnico si è rivelato un po' più ostico del previsto, perché le mie due liste erano composte da oggetti, ognuno con più di un parametro e una chiave generata in modo randomico, quindi il problema andrebbe riformulato come \"calcolare la differenza tra due liste di oggetti A e B basandosi su uno dei suoi parametri\"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Parlando in JavaScript:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"let nodesA = [\n  { a: '1', b: '1' },\n  { a: '2', b: '2' },\n  { a: '3', b: '3' },\n  { a: '4', b: '4' },\n  { a: '5', b: '5' },\n]\nlet nodesB = [\n  { a: '1', b: '6' },\n  { a: '2', b: '7' },\n  { a: '3', b: '8' },\n  { a: '6', b: '9' },\n  { a: '7', b: '10' },\n  { a: '8', b: '11' },\n]\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Come fare dunque a ottenere come risultato nodesA / nodesB, basandosi sul parametro a?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Questa è la prima versione a cui ho pensato:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"let result = []\nnodesB.forEach((nb) => {\n  let supportArr = []\n  nodesA.forEach((na) => {\n    supportArr.push(na.a)\n  })\n  const notInNodesA = supportArr.indexOf(nb.a) === -1\n  if (notInNodesA) {\n    result.push(nb)\n  }\n})\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"È davvero brutta lo so, è quadratica quindi non ottimale ed è anche un po' scomoda da utilizzare, quindi ho dovuto per forza RIFATTORIZZARE.\nInizialmente mi sono messo in testa di usare il filter e la map, ma non riuscivo a incastrare le cose come volevo (ottenevo o troppi dati o quelli che non mi interessavano) e nella mia ricerca mi sono imbattuto nel concetto di "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Currying"},"children":[{"type":"text","value":"currying"}]},{"type":"text","value":" visto all'università, ma mai utilizzato in pratica.\nLa definizione più semplice e immediata l'ho trovata su "},{"type":"element","tagName":"a","properties":{"href":"https://stackoverflow.com/questions/36314/what-is-currying"},"children":[{"type":"text","value":"StackOverflow"}]},{"type":"text","value":" e poi con l'aiuto di un bel post trovato "},{"type":"element","tagName":"a","properties":{"href":"https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe"},"children":[{"type":"text","value":"qua"}]},{"type":"text","value":" sono riuscito dopo un po' di tentativi ed errori a giungere a questo risultato."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ho definito la funzione "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodeCompare"}]},{"type":"text","value":" in questo modo:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"const nodeCompare = (otherArray) => {\n  return (current) => {\n    return (\n      otherArray.filter((other) => {\n        return other.a === current.a\n      }).length === 0\n    )\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"e poi l'ho utilizzata così:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"text","value":"const difference = nodesB.filter(nodeCompare(nodesA))\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ho quindi applicato all'array "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodesB"}]},{"type":"text","value":" un filtro che riceve come callback "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodeCompare"}]},{"type":"text","value":".\nLa funzione nodeCompare riceve come parametro l'array "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodesA"}]},{"type":"text","value":" che restituisce a sua volta il risultato di un filtro applicato sul "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nodesB"}]},{"type":"text","value":", e se il risultato è vuoto o pieno mi restituirà "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" o "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"false"}]},{"type":"text","value":" permettendo al primo filter lanciato di decidere se il valore è di mio interesse oppure no.\nUn salto di qualità notevole dopo la prima versione!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Spero con questo piccolo post di aver aiutato qualcuno o anche semplicemente spronato al REFACTORING, cosa che noi Inglorious Coders diciamo di fare sempre!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"# Giosk\n"}]}]}],"data":{"quirksMode":false}},"raw":"\r\nOggi mi sono trovato davanti a un problema a prima vista molto semplice da realizzare, ma il cui risultato si è rivelato orribile e per niente ottimale.\r\nIl problema si descrive molto facilmente in linguaggio naturale \"calcolare la differenza tra due liste A e B\".\r\nFacile no? A prima vista sì, ma scendendo nel tecnico si è rivelato un po' più ostico del previsto, perché le mie due liste erano composte da oggetti, ognuno con più di un parametro e una chiave generata in modo randomico, quindi il problema andrebbe riformulato come \"calcolare la differenza tra due liste di oggetti A e B basandosi su uno dei suoi parametri\".\r\n\r\nParlando in JavaScript:\r\n\r\n```js\r\nlet nodesA = [\r\n  { a: '1', b: '1' },\r\n  { a: '2', b: '2' },\r\n  { a: '3', b: '3' },\r\n  { a: '4', b: '4' },\r\n  { a: '5', b: '5' },\r\n]\r\nlet nodesB = [\r\n  { a: '1', b: '6' },\r\n  { a: '2', b: '7' },\r\n  { a: '3', b: '8' },\r\n  { a: '6', b: '9' },\r\n  { a: '7', b: '10' },\r\n  { a: '8', b: '11' },\r\n]\r\n```\r\n\r\nCome fare dunque a ottenere come risultato nodesA / nodesB, basandosi sul parametro a?\r\n\r\nQuesta è la prima versione a cui ho pensato:\r\n\r\n```js\r\nlet result = []\r\nnodesB.forEach((nb) => {\r\n  let supportArr = []\r\n  nodesA.forEach((na) => {\r\n    supportArr.push(na.a)\r\n  })\r\n  const notInNodesA = supportArr.indexOf(nb.a) === -1\r\n  if (notInNodesA) {\r\n    result.push(nb)\r\n  }\r\n})\r\n```\r\n\r\nÈ davvero brutta lo so, è quadratica quindi non ottimale ed è anche un po' scomoda da utilizzare, quindi ho dovuto per forza RIFATTORIZZARE.\r\nInizialmente mi sono messo in testa di usare il filter e la map, ma non riuscivo a incastrare le cose come volevo (ottenevo o troppi dati o quelli che non mi interessavano) e nella mia ricerca mi sono imbattuto nel concetto di [currying](https://en.wikipedia.org/wiki/Currying) visto all'università, ma mai utilizzato in pratica.\r\nLa definizione più semplice e immediata l'ho trovata su [StackOverflow](https://stackoverflow.com/questions/36314/what-is-currying) e poi con l'aiuto di un bel post trovato [qua](https://medium.com/@kbrainwave/currying-in-javascript-ce6da2d324fe) sono riuscito dopo un po' di tentativi ed errori a giungere a questo risultato.\r\n\r\nHo definito la funzione `nodeCompare` in questo modo:\r\n\r\n```js\r\nconst nodeCompare = (otherArray) => {\r\n  return (current) => {\r\n    return (\r\n      otherArray.filter((other) => {\r\n        return other.a === current.a\r\n      }).length === 0\r\n    )\r\n  }\r\n}\r\n```\r\n\r\ne poi l'ho utilizzata così:\r\n\r\n```js\r\nconst difference = nodesB.filter(nodeCompare(nodesA))\r\n```\r\n\r\nHo quindi applicato all'array `nodesB` un filtro che riceve come callback `nodeCompare`.\r\nLa funzione nodeCompare riceve come parametro l'array `nodesA` che restituisce a sua volta il risultato di un filtro applicato sul `nodesB`, e se il risultato è vuoto o pieno mi restituirà `true` o `false` permettendo al primo filter lanciato di decidere se il valore è di mio interesse oppure no.\r\nUn salto di qualità notevole dopo la prima versione!\r\n\r\nSpero con questo piccolo post di aver aiutato qualcuno o anche semplicemente spronato al REFACTORING, cosa che noi Inglorious Coders diciamo di fare sempre!\r\n\r\n```\r\n# Giosk\r\n```\r\n"}